<div align=center>
<img alt="Tom Hendra logo" src="https://res.cloudinary.com/tomhendra/image/upload/v1567091669/tomhendra-logo/tomhendra-logo-round-1024.png" width="100" />
<h1>Master the Coding Interview: Data Structures & Algorithms</h1>
<p>Notes from the course.</p>
</div>

## Introduction

This is a **[Udemy course](https://www.udemy.com/course/master-the-coding-interview-data-structures-algorithms/)**. by Andrei Neagoie.

The development server is run with [parcel](https://parceljs.org/getting_started.html):

```sh
parcel index.html
```

The introduction explains that the course is made up of two main parts.

- 1. Non-technical aspects of interviews.
- 2. Technical interview topics: data structures & algorithms.

## Getting More Interviews

How to ensure you get more interviews through using the best channels and tactics.

- Being great at anything won't get you a job without getting an interview.
- The more interviews you get, the better your chances are to get a great job.
- Practising interview skills is key to performing well in interviews.
- First step is actually getting the interview.
- If you applying to 100 jobs and only getting one interview, you're probably doing something wrong.
- Should not take any more than a week to set yourself up for applying to jobs.

### Resumes

- Resumes are scanned in 10 seconds by recruiters and are simply a way to get interviews.
- Spend no longer than a day on your resume.
- Have words and characteristics from job posts you want to apply for on the resume.
- Make the resume personal to each job you apply to so you have the company name on resume.
- Use online tools to generate well designed resume. Your time is better spent writing code!
- Companies often use algorithms to search for keywords from the job listing.
- key points for resume:
  - should be one page only.
  - Should only contain relevant skills, using keywords from job description.
  - Should be personalized for each application. One of the biggest mistakes is not doing so.
  - should be an online link to portfolio or GitHub etc.
- Resume cheat sheet:
  - ✅ Use a pre-designed resume template
  - ✅ Make the resume fit on 1 page
  - ✅ Include words from job description
  - ✅ Include company name you are applying to
  - ✅ Does your first item on your resume reflect what they are looking for?
  - ✅ Experience titles demonstrate value
  - ✅ Do you have an online link?
  - ✅ Remove the word “I”
  - ✅ No buzzwords describing how great you are
  - ✅ Are you using Action words?
  - ✅ Measure everything in terms of impact, don’t just describe your responsibilities
  - ✅ Technical Knowledge/Skills should include what they are looking for. Only show years if it is impressive
  - ✅ Include only sections/items that are impressive: Experience, Projects, Education, Technical Skills
  - ✅ No typos or bad grammar

### What if I lack experience?

- Apply to jobs that you are under-qualified for.
- Job postings are designed to weed out the weak candidates.
- If you are applying to a job that you are 100% qualified for, how will you grow?
- You can demonstrate experience without having a past job by having 3 of the below:
  - GitHub: Make commits. Contribute to open source.
  - Website: Doesn't need to be complicated.
  - 1-2 big projects: Big, challenging projects much better than numerous simple ones.
  - Blog

### LinkedIn

- If you craft things well enough, you will get lots of recruiters' contact.
- Should be similar to your resume.
- Recruiters usually search LinkedIn for keywords.
  - 1. Apply for jobs through LinkedIn.
  - 2. Update your profile every week on LinkedIn to show up in recruiter's feed, as updated profile.
  - 3. Include keywords recruiters are looking for from the jobs you are applying for.
  - 4. Try to get recommendations from people to rank higher in recruiters' search results.
  - 5. LinkedIn allows us to target companies and contact people directly at a company you want to work for.

### Portfolio

- A way to showcase your big projects.
- Allows you to demonstrate your value.
- Projects inside portfolio are more important than the portfolio itself.
- Can be simple, as long as it's fast and looks nice.
- Add to ZTM job board once it's done.

### Email

- Applying for a job through a company's website or job board is not the best way to apply.
- Employee referral has proven to be the best way to get an interview.
- The most obvious method is to apply to places where friends and colleagues can refer you.
- Use LinkedIn to find people to send direct messages to.
- Use tools to find people's email addresses.
- Target people who are gatekeepers.
- Most big companies have incentives for referring someone.
- Doesn't have to be online only, meetups and hackathons work too.
- Nothing beats a referral.
- Rather than sending a resume, send a link to your portfolio and directly ask if you can come in for an interview. Ask the head of HR if you wish.
- Message lead developers or CTO and let them know you are interested in working for their company, would like to be where they are professionally. But don't ask for a job directly, rather ask whether they can meet for coffee to talk about themselves, and perhaps you can learn from them and find a referral.
- Message CEO or president directly for smaller companies.
- sample message:

Hey $BOB,
I saw your presentation at $CONFERENCE last year on Youtube (rr point to some work they have done).
Great stuff; loved what you did with $FOO, in particular
$COMMENT_PROVING_YOU_KNOW_WHAT_YOU'RE_TALKING_ABOUT.
I'm also a $FOO developer. I noticed that your company is hiring
or $ROLE. I’d love to be a part of your team. Do you have a
few minutes to chat on Thursday about what you guys are doing?

Thanks,
Yourname
Your website or any public profile link

### Where to finds jobs

- Development is highly in demand, so there are a tonne of resources.
- The better you get at engineering, the easier it will be to find work.
- Resources:
  - LinkedIn
  - [Hackernews who is hiring?](https://www.google.com/search?client=firefox-b-d&q=hackernews+who+is+hiring)
  - [AngelList](https://angel.co/jobs)
  - [Design Modo](https://designmodo.com/jobs/)
  - [Remote List](https://www.remotelist.pw/)
  - [Remote Only](https://remoteonly.io/)
  - [We Work Remotely](https://weworkremotely.com/)
  - [Remote OK](https://remoteok.io/)
  - [Meetup](https://www.meetup.com/): great way to network for referrals.
  - Google e.g. site:linkedin.com \$companyName recruiter
  - [Hired](https://hired.com/), [Triplebyte](https://triplebyte.com/), [Whitetruffle](https://whitetruffle.com/): code quiz sites
- job hunting is a numbers game. for 2% hit rate, apply to 50 companies.
- Blindly applying to companies is much less efficient than targeting directly i.e. eventual referral.

### When to start applying for jobs

- Short answer is -- Apply now! Use it as practice.
- Interviews shouldn't be looked at like win or lose, more they are a skill to be developed.
- The more interviews you take, the better you will become at taking them.
- If you are applying to a job where you check all the boxes is a bad thing for growth.
- Job description is a guideline for what work you will be doing, rather than what you have done in the past.
- Do you know the fundamental building blocks of computer science?
- Have and can you build big projects on your own?
- Hiring developers and engineers are more than just technical knowledge.
- If you never ask the answer is always "no"!

### Summary

- Don't apply to 1000 positions online just sending resume everywhere, like most people.
- Pick 5-10 companies you want to work for, and fully target and focus on applying to them.
- Increase chances of interview by setting up all points covered here over a week.
- Focus on the projects to talk about in interview.
- Contact directly and get referrals rather than applying anonymously.
- The focus is on quality over quantity.

## Big O

A paradigm to classify code according to how runtime or space requirements grow as the input size grows.

- One of the most important topics for software engineering.
- A concept that will always be relevant and make you a better engineer.
- You won't get by any of the big company's interviews without knowing big O.
- Full name is big o asymptotic analysis.
- Big O helps us tell how well a problem is solved.
- Two main things to define good code:
  - 1. Readability: Clean, easy to follow.
  - 2. Scalable: Big O allows us to measure.
- The "runtime" is how much time it takes to run through a function or task.
- Big O measures the performance of code.
- Code runs at different speeds depending on the computer it's running on.
- Big O notation is the language we use to talk about how long an algorithm takes to run: algorithmic efficiency.
- Defines how well code will run regardless of the machine that's running it.
- The less that the function slows down with scale, the better the code is.
- Big O concerns us with how many steps are in a function.
- Scalability defined by the size of the input (n) compared to the number of operations that increase.
- O(n) is linear time, and probably the most common notation, where the number of operations increases proportionally with the number of inputs.
- O(1) is constant time. The number of operations remains constant regardless of the input size.
- Big O rule book:
  - 1. Worst case
    - when calculating big O we always calculate the worst case.
  - 2. Remove constants
    - we only care about input for scalability. Trim out constants.
  - 3. Different terms for inputs.
    - When two more than one input is given to correct notation should be applied.
    - Easy rule of thumb is that any functions that occur in the same indentation would be O(a + b) and any nested functions would be O(a \* b) i.e. O(n^2) quadratic time.
  - 4. Drop non-dominants
    - The most significant term should be what defines big O e.g. O(n + n^2) would become O(n^2)
- To write scalable code means thinking long term, what could happen in the future.
- Everything has a cost to it.
- O(n!) is factorial time, and the most expensive. Nested loop for every input there is!
- for scalable code there are two things we need to consider:
  - 1. Speed: How fast is the runtime - time complexity.
  - 2. Memory: How much RAM does the code require - space complexity.
- Which code is best can be answered with the three pillars of code:
  - **1. Readable**
  - **2. Speed**
  - **3. Memory**
- There is usually a trade-off for any solution between speed and memory.
- When a program executes it has two ways to remember things:
  - 1. Heap: usually where we store variables.
  - 2. Stack: where we keep track of function calls.
- Space complexity is caused by:
  - 1. Variables
  - 2. Data structures
  - 3. Function calls
  - 4. Allocations
- One of the biggest gotchyas is that we don't count the space of inputs.
- We only have control over what happens inside of the function, so input space is ignored.
- We look at whether we are adding space inside the function.

## How to solve coding problems.

How to approach problems and solve them in the optimal way for interviews.

- An interview is a way for the company to find out whether you can solve problems.
- If you can solve problems then you are valuable.
- It's not the smartest interviewer that gets hired, it's the one who can solve the company's problems.
- It's not necessarily about the solution to the problem in interview, it's about the thought process.
- Companies are looking for four things:
  1. Analytical skills
  2. Coding skills
  3. Technical skills
  4. Communication skills
- In order to solve coding problems in interview we need to know the following:
- **Data structures:**
  - Arrays
  - Stacks
  - Queues
  - Linked Lists
  - Trees
  - Tries
  - Graphs
  - Hash Tables
- **Algorithms:**
  - Sorting
  - Dynamic programming
  - BFS & DFS
  - Recursion
- [Google Interview](https://www.youtube.com/watch?v=XKu_SEDAykw)
- Always think out loud and explain your approach, even if you think you know the answer, allowing the interviewer opportunity to steer you if needed to ensure you understand the problem correctly.
- Communicating a naive / brute force solution first, often O(n^2), shows you are thinking clearly about the problem.
- Thinking in small logical steps is much better than trying a more complicated solution straight away.
- Don't try to solve the problem fast.
- Don't try to memorize problems, instead practice fundamentals to tackle any problem.
- The assumption is that some people solve problems better than others, but in reality like anything you can train.

## Data structures

How to organize, format and store collections of data values, the relationships among them, and the functions or operations that can be applied to the data.

- A data structure is a collection of values used to organize data.
- Values can have relationships between them and functions applied to them.
- Each data structure is good and is specialized for its own thing.
- Algorithms are the steps or processes that we put into place to manipulate the values in data structures
- A person who knows how data structures & algorithms can write great programs.
- Data structures & algorithms are timeless, and can be applied to any language or problem.
- There is always a tradeoff between readability, memory and speed (3 pillars).
- Two parts to understanding data structures:
  - 1. How to build
  - 2. How to use - most important!
- In order to understand data structures we need to look at how computers work at the fundamental level.
- Computer needs to be able to keep track for variables which are stored in RAM.
- RAM is much faster than persistent storage for CPU access.
- RAM has numbered address which each hold 8 bits (1 byte).
- CPU connects to memory controller which reads and writes from RAM.
- Bits can be accessed at any random address instantly.
- Programs can run faster when accessing memory addresses that are close to one another.
- CPU cache optimizes further by storing recently accessed data from memory.
- You can define the way you interact with data and how it is arranged in RAM.
- Some data structures are organized next to each other and some are apart, and each have different pros and cons on access and write.
- Our goal is to minimize the operation that the COP needs to do to read and write information.
- That's why data structures are so powerful, because we can think on the the low level about how data structures affect the process of our computers.
- Each data structure performs operations differently.
- Operations on data structures:
  - Insertion: add a new data item in a given collection of items.
  - Deletion: remove data.
  - Traversal: access each data item exactly once so that it can be processed.
  - Searching; find the location of a data item if it exists in a certain collection.
  - Sorting: sorting data.
  - Access: how do we access data.

### Arrays

- Sometimes called lists.
- Organize data sequentially in memory (contiguous).
- Probably the simplest and most widely used data structure.
- Smallest footprint of any data structure.

  - search: O(n)
  - lookup: O(1)
  - append: O(1) or worst case O(n) based on reallocation of memory
  - insert: O(n)
  - delete: O(n)

- Two types of arrays: Static and dynamic
- Static arrays are fixed in size - need to specify the number of elements ahead of time.
- Arrays are allocated in adjacent blocks of memory when created, but there is no way to guarantee that later adding to the array will use more adjacent blocks. Static arrays solve this problem.
- Dynamic arrays allow us to copy and rebuild an array at a new location in memory, with more memory if required.
- JavaScript arrays work like dynamic arrays and automatically allocate memory.
- We can create our own data structures, any we want from scratch.
- **Top tip:** Treat and string questions in interviews like array questions. Strings are simply an array of characters. Convert into array, perform operations, return as string!
- The good:
  - Fast lookups
  - Fast push/pop
  - Ordered
- The bad:
  - Slow search
  - Slow insert
  - Slow delete
  - Fixed size (with static arrays)

### Hash tables

- AKA hash maps, maps, unordered maps, dictionaries, objects depending on language.
- Objects in JavaScript are a type of hash table.
- Seen a lot in databases and caches.
- Made up of key: value pairs.
- A hash function is simply a function that generates a value of fixed length for each input that it receives.
- Hash functions are one way, it's practically impossible to retrieve input.
- A hash function is **idempotent** - always produces the same output when provided with a certain input.
- Hash functions are optimized to be very fast for the purpose of hash tables.
- Some hash functions are very slow e.g. SHA-256 for encryption.
- In hash tables, the key is passed into the hash function, then the outputted hash is mapped to a memory address where the data is stored.
- Usually time complexity of O(1) - constant time

  - search: O(1)
  - lookup: O(1) - or can be O(n) due to hash collisions.
  - insert: O(1)
  - delete: O(1)

- Hash collision occurs when the same address space is allocated for more than one entry based on the hash output.
- This results in the 'bucket' which stores key / value pair having overflow entries.
- Theoretically due to collision read / write can be O(n/k) (O(n) simplified) where k is the size of the hash table.
- Many ways to deal with hash collisions - see [Wiki](https://en.wikipedia.org/wiki/Hash_table).
- in JavaScript ES6 the Map() object allows you to save any data type as the key, instead of only strings pre-ES6.
- Another benefit of Map is is that it maintains insertion order.
- ES6 Set() in JS stores only keys, no values.
- The good:
  - Fast search
  - Fast lookup
  - Fast insert
  - Fast delete
  - Flexible keys
- Thee bad:
  - Unordered
  - Slow key iteration
  - Collisions

### Linked lists

- Two types to be covered: singly and doubly linked lists
- A singly linked list contains a set of node, each containing two elements: a value and a pointer to the next node.
- There is a head and tail node to indicate beginning and end of the list.
- Linked lists are null terminated, i.e. tail node points to null.
- In arrays each item is indexed. In linked lists you start at the head and traverse the list - O(n).
- Memory addresses are not sequential, so unable to take advantage of caching systems for speed advantage.
- Traversing linked lists is usually slower than iterating through array items.
- However inserts into the middle of linked lists is faster than in an array.

  - Prepend: O(1)
  - Append: O(1)
  - Lookup: O(n)
  - Insert: O(n)
  - Delete: O(n)

- A pointer is a reference to another place in memory.
- Because JS is garbage collected (memory is managed automatically) pointers are deleted when data is deleted.
- Doubly linked lists exactly the same as singly linked lists, but have additional pointer to previous node.
- Doubly linked lists allow us to traverse backwards.
- Lookup can technically be O(n / 2).
- The downside is that we may need to hold an additional block of memory.
- Interviewers love to ask questions about linked lists because it requires a lot of information to be held in your head, and you have to think about the steps.
- Don't memorize the implementation, learn to think about the steps.
- Singly vs Doubly:
  - Singly is simpler
  - Singly requires less memory
  - Singly can't be traversed in reverse.
  - Singly for insertion & deletion and not much searching
  - Doubly for searching and deletion of previous nodes
  - Doubly fairy complex, and requires more memory.
- Most of the time in interviews singly linked lists are asked about.
- Reversing a linked list is a very popular question, and probably the hardest concept to grasp in this entire course!
- The good:
  - Fast insert
  - Fast delete
  - Ordered
  - Flexible size
- Thee bad:
  - Unordered
  - Slow lookup
  - More memory

### Stacks & queues.

- Both linear data structures allowing sequential traversal.
- No random access, usually only the first and last elements.
- Having a limited ability on certain data structures can be an advantage.
- By limiting what a user can do it gives control to use only efficient operations.

- Stacks:

  - Lookup: O(n)
  - Pop: O(1)
  - Push: O(1)
  - Peek: O(1)

- Queues:

  - Lookup: O(n)
  - Enqueue: O(1)
  - Dequeue: O(1)
  - Peek: O(1)

- Stacks are LIFO (last in first out).
- Queues are FIFO (first in first out).
- Arrays have cache locality for technically faster access when items are next to each other, whereas linked list memory addresses are scattered. Linked lists however have more dynamic memory, whereas static arrays would need to reallocate memory when capacity is reached. Stacks could be implemented with either depending on the situation.
- Queues should never be implemented with arrays since queue / dequeue would require reindexing.
- One of the most common interview questions is to implement a queue using stacks.
- The good:
  - Fast operations
  - Fast peek
  - Ordered
- Thee bad:
  - Slow lookup

### Trees

- Have a hierarchical structure, as opposed to arrays or link lists which are linear.
- Usually starts with a root node and every child descends from the root.
- Every child of a node descends from only one parent.
- A unidirectional parent-child relationship between nodes.
- Leaf nodes are the end of a tree data structure.
- Can have subtrees.
- Examples of a tree: DOM, AST.
- Linked list is technically a type of tree, albeit with a single path.
- A node can only point to a child.

#### Binary trees

- Each node can only have either 0, 1 or 2 children, and each child can only have 1 parent.
- Each node represents a certain state.
- A perfect binary tree node has either 0 or 2 children, and all leaf nodes full all the way to the bottom.
- A full binary tree node simply has either 0 or 2 children but never 1.
- A perfect binary tree is very efficient and desirable, and has two important properties:

  - 1. Number of total nodes on each level doubles as we move down the tree.
  - 2. Number of nodes on the last level is equal to the sum of the number of all other nodes + 1. Because of the efficiency in traversal by not visiting each node, O(log n) can be applied.

  - lookup: O(log n)
  - insert: O(log n)
  - delete: O(log n)

- [O(log n) explained](https://medium.com/better-programming/a-gentle-explanation-of-logarithmic-time-complexity-79842728a702)

#### Binary search trees

- Great for searching and comparing things.
- Preserves relationships between nodes.

  - Rules:
  - 1. All child node values in the tree to the right of the root node must be greater than the current node value.
  - 2. A node can only have up to 2 children.

- If binary search tree is unbalanced, lookup, insert & delete can become O(n) where every node requires traversal.
- Ideally we want to balance our search tree to ensure optimum performance.
- Usually in production it is best to have a balanced search tree. Two popular types of trees for this purpose:
  - 1. AVL Tree
  - 2. Red / Black Tree
- The good:
  - Better than O(n)
  - Ordered
  - Flexible size
- The bad:
  - No O(1) operations

#### Binary heaps

- Type of tree where every child belongs to a parent node which has a greater priority or value.
- Max heap is where root node is the greatest.
- Min heap id where root node is the smallest.
- Every node on the top level has a greater value than every node on the next level down.
- Good for when there is an order, particularly for priority queues.

  - lookup: O(n)
  - insert: O(log n)
  - delete: O(log n)

- Slower lookup than BST because it's less ordered. left / right can be any value as long as it is less than the top value.
- Heaps add value on the tree in order from left to right, then bubbles up of the priority order isn't right.
- Because value are always added LTR, binary heaps are always balanced automatically, and are very compact and memory efficient for this reason.
- Priority queues have elements which have different priorities.

#### Tries

- A specialized tree used for searching, most often text.
- Most cases can outperform BST, hash tables, and most other data structures discussed so far.
- Allow you to know if a word or part of a word exists in a body of text.
- AKA prefix tree.

### Graphs

- Graphs are one of the most useful and used data structures used to represent real world data.
- A set of values that are related in a pair-wise fashion.
- Each item is called a node or a vertex, connected with edges.
- Certain characteristics are used to describe graphs:
  - Directed (one way) vs undirected (bi-directional).
  - Weighted (info in edges) vs unweighted.
  - Cyclic vs Acyclic
- Graphs are built on top of other data structures.
- Three ways to think about building graphs:
  - 1. Edge list
  - 2. Adjacency list
  - 3. Adjacency matrix
- When it comes to interviews, other data structures are more popular than graphs.
- The good:
  - Relationships
- The bad:
  - Scaling is hard

## Algorithms

- Algorithms are just functions that programmers write.
- Simply steps in a process to take desired actions in a computer program.
- Algorithms allow us to use data structures to perform actions on data.
- Data structures + algorithms = computer programs.
- Scalability of code is important as companies get larger.
- By learning these four topics we are able to do the majority of the scaling we need to improve our programs.
  - 1. Sorting
  - 2. Dynamic programming
  - 3. BFS & DFS
  - 4. Recursion
- Some algorithms allow us to simplify our big O complexity to smaller time complexity.
- Used everywhere in large companies because they deal with large amounts of data.

### Recursion

- Recursion is a concept, not an algorithm.
- One of the most popular topics in interviews.
- A function that refers to itself inside of the function.
- Really good for tasks that have repeated subtasks to do.
- Not that complex as long as you practice a little bit.
- If there is no way to stop a recursive call, stack overflow can happen where memory runs out.
- Every recursive function needs a base case / stop point.
- Recursive functions have two paths:
  - 1. Call the function again and run it (recursive call).
  - 2. Stop calling the function, there is nothing more to search for (base case).
- Anything that can be implemented recursively, can be implemented iteratively.
- Recursion is not always the best approach. A good engineer uses the right solution for the particular problem.
- The good:
  - DRY code
  - Readability
- The bad:
  - Large stack

#### When to use recursion

- A good rule -- when you are working with data structures which you are not sure how deep they are.
- Tail call optimization allows recursions to be called without increasing the call stack.
- For traversing trees or graphs (BFS / DFS) recursion is better than iterative.
- Recursion can be preferred for certain sorting.
- Whenever we are using a tree or converting something into a tree, consider recursion.
- 3 rules to follow for when a recursive problem presents itself in interview:
  - 1. Divided into a number of subproblems that are smaller instances of the same problem.
  - 2. Each instance of the subproblem is identical in nature.
  - 3. The solutions of each subproblem can be combined to solve the problem at hand.
- Divide & conquer using recursion.

### Sorting

- Sorting is really important in interviews.
- Sorting is not important when it comes to small input data, but is very important as data grows larger.
- Big companies need custom sorting methods to reduce expense.
- You need to be able to decide which sorting algorithm is most appropriate for the given problem.
- As more data needs to be handled, sorting and searching are two of the biggest problems to be solved in CS.
- The problem with JS sort() method is that numbers are converted to strings and sorted by unicode.
- Also language specific characters e.g. á confuses sorting further (can use localeCompare()).
- You don't need to write a sorting algorithm from scratch. Usually frameworks are used.
- There is always big O tradeoffs.
- Certain types of sorting algorithms are more efficient for certain situations: [Demo](https://www.toptal.com/developers/sorting-algorithms)
- Elementary sorting algorithms are basic: Bubble sort, Insertion sort & Selection sort.
- More complex sorting algorithms are usually more efficient than elementary. They include Merge sort & Quick sort.

#### Bubble sort

- One of the simplest but least efficient sorting algorithms: O(n^2) time complexity.

#### Selection sort

- Finds the minimum by comparing all values in the array and places the minimum at the beginning after comparing all values.
- O(n^2) time complexity.

#### Insertion sort

- Not the most efficient algorithm, but there are cases where it is extremely fast.
- Useful for times when the list is almost sorted.
- Performs well with small datasets.
- Best case scenario is O(n) linear time.

#### Merge sort

- Uses divide & conquer.
- Much more efficient than elementary sorting algorithms.
- Usually O(n log n).
- One of the most efficient ways you can sort a list.

#### Quick sort

- Uses divide & conquer.
- Uses a pivoting technique & breaks a list into smaller lists.
- More complex to understand than merge sort.
- Quick sort (and merge sort) are the most commonly used sorting algorithms.
- Usually O(n log n).

#### Which sort is best?

- Insertion sort should be used with only a few items. If input is small and nearly sorted.
- Bubble sort - never used in production. For educational purposes only.
- Selection sort - most likely used for educational purposes, as bubble sort.
- Merge sort is great because of divide & conquer. Always guaranteed to be O(n log n), even worst case. But space complexity is expensive.
- Quick sort - better than merge sort for space complexity, but worst case time complexity O(n^2).
- Mathematically it is impossible to beat time complexity of O(n log n) for comparison sort.
- Non-comparison sort can beat O(n log n) -- Counting sort, Radix sort. But only work with integers in a small range.

### Searching

- Searching is something that is used frequently.
- A big part of application development.
- As more data accumulates it is important to know how to perform fast searches.

#### Linear search

- AKA sequential search is a method of finding a target value in a list.
- Sequentially checks each element in the list until the target value is found.
- Linear time O(n) is not that fastest searching algorithm.

#### Binary search

- If a list is sorted, we can use divide & conquer to improve on O(n).
- Storing data in a tree is more efficient to perform search on.
- O(log n) time complexity by using a binary search tree as data structure.

#### Graph & Tree traversal

- 'Traversal' and 'search' terms are often used interchangeably.
- Traversals visit every node, so O(n) linear time.
- Two options for traversal: Breadth First Search (BFS), and Depth First Search (DFS).
- For both graphs and trees the time complexity is the same.
- The main benefit of putting complex data into trees or graphs is to enable O(log n) search.
- Also insert and delete is faster.

#### Breadth First Search (BFS)

- Start with the root node, then move left to right across subsequent levels.
- Keep going until you find the node you are looking for or the tree ends.
- BFS uses additional memory because it is necessary to track the child nodes of all nodes on a given level.

#### Depth First Search (DFS)

- Follows one branch of the tree down as many levels as possible, until target node is found or end is reached.
- When the search cannot continue it moves to the nearest ancestor with an unexplored child.
- Has a lower memory requirement than BFS because it is not necessary to store all child pointers at each level.
- Three types of traversal:
  - InOrder: Nodes from left to right
  - PreOrder: Nodes from left to right, starting with root node and respecting ancestors.
  - PostOrder: Nodes from left to right, starting with bottom, then moving upwards towards parent nodes.

#### BFS vs DFS

- Time complexity is the same -- O(n).
- BFS: Good for shortest path, because we always start with the root node then search the closest nodes first.
- BFS: Requires more memory than DFS.
- BFS: If the node is likely to be in the upper level of the tree, BFS is good.
- DFS: Good at verifying if the path exists.
- DFS: Uses less memory than BFS.
- DFS: Can be slower if the tree has many levels.

#### Dijkstra & Bellman-Ford algorithms

- Complex algorithms to find the shortest path.
- Bellman-ford is better than Dijkstra's for finding the shortest path as it supports negative weights.
- However Bellman-ford time complexity is O(n^2), not the most efficient.
- Dijkstra's algorithm is more efficient, but doesn't support negative weights.

### Dynamic programming

- Dynamic programming is an optimisation technique using caching. It means nothing, just a buzzword.
- A way to solve problems by breaking it down into subproblems, and storing the subproblems in case they reoccur.

#### Memoization

- Caching is a way to store values so you can use them later.
- A way to speed up programs by retrieving reusable information and avoiding recalculation.
- Memoization is a specific form of caching that involves caching the return value of a function based on its parameters.
- If the parameter remains the same, then it's memoized i.e. the calculation has already been performed and the cached value is returned.
- Good practice to ensure the cache doesn't pollute the global scope, and use closure.
- Dynamic programming can be thought of as divide & conquer + memoization.
- Steps to follow for whether dynamic programming is suitable:
  1. Can the problem be divided into subproblems?
  2. Recursive solution
  3. Are there repetitive subproblems?
  4. Memoize subproblems

## Non-technical interviews

- Coding is just part of an interview.
- Non-technical interviews are for behavioural questions, asked to see whether you are a good fit for the company.

### Mindset

- The biggest mistake going into interview is thinking that it is your only chance.
- Know that you have many other opportunities. It is not pass or fail.
- Treat everything as a learning experience.
- Don't hope for a job, or anything at all. Just go for the experience.
- It is just another practice session.
- Your interviewer is likely to be more excited about interviewing, if you are excited to be there.
- Your goal is to enter the room with a lot of energy, be happy to be there.
- The interviewer will match your energy.
- Before you go into the interview, think to yourself that you are going to meet an old friend and you are happy to be there. This is a proven psychological technique.
- Excitement is a signal that you actually want to job.

### Hero Stories

- An interviewer wants to answer 3 questions:
  - Can you do the job? (technical)
  - Can I work with you? (behavioural)
  - Are you going to improve? (behavioural)
- Before you enter interviews you need to have 2 - 4 stories prepared (4 heroes).
- All behavioural questions in interview can be related back to these stories.
- Stories should demonstrate the following qualities:
  1. Challenge - going through something challenging and how you overcame it.
  2. Technical - a difficult project fom your portfolio. You know a lot about it.
  3. Success - if you built something, what did you do. Past promotions.
  4. Leadership - are you the type of person who can take initiative.

### Tell me about yourself

- Should be preprepared.
- Answer this question in about 1 minute.
- A chance for you to steer the conversation towards your hero stories.
- Tell your heroes journey, how you went from someone from very little skill, to someone they want to hire.
- The interviewer will ask follow up questions based on this.
- Your journey should cover the story pointers
- Your triggers of success.
- Mention things you want to get asked.
- Skills should be relevant to job.
- Mention some of the skills you would be working with at the job.
- Demonstrate they will be extremely lucky to have you, and how everything you have done in the past makes it a perfect role for you.
- The interviewer may not even have looked at your resume.
- What did you do that makes you stand out.
- Exercise you pitch: cover the four qualities:
  1. Challenge.
  2. Technical.
  3. Success.
  4. Leadership.

I became really interested in coding a few years ago when I offered to build an e-commerce website for my best friend's record label. He always knew me to be interested in computer hardware and design, and so offered the opportunity to me. I chose to use WordPress and WooCommerce, but became frustrated with the theme's built-in limitations, and found out I could add custom CSS and that's what sparked my interest. I found MDN and was hooked! I finished the website in time for a new track release, and as 1000's of users downloaded the track while the performance remained stable (Kinsta) it gave me a huge buzz! When I got paid for the site it gave me the idea that I could build websites for a living, since I was stagnating in my job at the time, so I started learning to code after work with Codecademy & Treehouse.

About six months later my best friend passed away suddenly at 33, which hit me really hard, and made me reflect on life. At the same time my fiancée was to be made redundant from her job in the UK. We always had a dream of moving to Spain one day, and with everything that had happened we decided to go for it. So I gave six months notice on my job, we saved hard, sold everything we could, and moved to Spain where I could study web development full time and my partner could look for work as a teacher.

I found Kamran Ahmed's Developer Roadmap, started learning JavaScript, React and built my portfolio with Gatbsy. As I learned more I improved my portfolio, each version making the code cleaner and more consistent. The components developed into a reusable API, MarkDown blog posts were replaced with Sanity CMS, I learned how to configure a monorepo with lerna and Yarn workspaces and deploy both to Vercel using their GitHub CI integration. At this point I was confident I could build performant JAMStack websites with a CMS, so I had the ability to freelance.

Then I started to work on more complicated projects to add to the portfolio, while learning more advanced topics from Frontend Masters and egghead.io, while writing blog posts to solidify what I learned (Feynman Technique).

Through these projects and through these posts, every day I am becoming better and better as a coder, to the point where I feel very confident that I could be a valuable asset to your team, not just now but in the years to come where I expect my abilities to exponentially grow.
