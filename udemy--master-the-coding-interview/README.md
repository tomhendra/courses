<div align=center>
<img alt="Tom Hendra logo" src="https://res.cloudinary.com/tomhendra/image/upload/v1567091669/tomhendra-logo/tomhendra-logo-round-1024.png" width="100" />
<h1>Master the Coding Interview: Data Structures & Algorithms</h1>
<p>Notes from the course.</p>
</div>

## Introduction

This is a **[Udemy course](https://www.udemy.com/course/master-the-coding-interview-data-structures-algorithms/)**. by Andrei Neagoie.

The JavaScript files are run with [parcel](https://parceljs.org/getting_started.html):

```sh
parcel index.html
```

The introduction explains that the course is made up of two main parts.

- 1. Non-technical aspects of interviews.
- 2. Technical interview topics: data structures & algorithms.

## Getting More Interviews

How to ensure you get more interviews through using the best channels and tactics.

- Being great at anything won't get you a job without getting an interview.
- The more interviews you get, the better your chances are to get a great job.
- Practising interview skills is key to performing well in interviews.
- First step is actually getting the interview.
- If you applying to 100 jobs and only getting one interview, you're probably doing something wrong.
- Should not take any more than a week to set yourself up for applying to jobs.

### Resumes

- Resumes are scanned in 10 seconds by recruiters and are simply a way to get interviews.
- Spend no longer than a day on your resume.
- Have words and characteristics from job posts you want to apply for on the resume.
- Make the resume personal to each job you apply to so you have the company name on resume.
- Use online tools to generate well designed resume. Your time is better spent writing code!
- Companies often use algorithms to search for keywords from the job listing.
- key points for resume:
  - should be one page only.
  - Should only contain relevant skills, using keywords from job description.
  - Should be personalized for each application. One of the biggest mistakes is not doing so.
  - should be an online link to portfolio or GitHub etc.
- Resume cheat sheet:
  - ✅ Use a pre-designed resume template
  - ✅ Make the resume fit on 1 page
  - ✅ Include words from job description
  - ✅ Include company name you are applying to
  - ✅ Does your first item on your resume reflect what they are looking for?
  - ✅ Experience titles demonstrate value
  - ✅ Do you have an online link?
  - ✅ Remove the word “I”
  - ✅ No buzzwords describing how great you are
  - ✅ Are you using Action words?
  - ✅ Measure everything in terms of impact, don’t just describe your responsibilities
  - ✅ Technical Knowledge/Skills should include what they are looking for. Only show years if it is impressive
  - ✅ Include only sections/items that are impressive: Experience, Projects, Education, Technical Skills
  - ✅ No typos or bad grammar

### What if I lack experience?

- Apply to jobs that you are under-qualified for.
- Job postings are designed to weed out the weak candidates.
- If you are applying to a job that you are 100% qualified for, how will you grow?
- You can demonstrate experience without having a past job by having 3 of the below:
  - GitHub: Make commits. Contribute to open source.
  - Website: Doesn't need to be complicated.
  - 1-2 big projects: Big, challenging projects much better than numerous simple ones.
  - Blog

### LinkedIn

- If you craft things well enough, you will get lots of recruiters' contact.
- Should be similar to your resume.
- Recruiters usually search LinkedIn for keywords.
  - 1. Apply for jobs through LinkedIn.
  - 2. Update your profile every week on LinkedIn to show up in recruiter's feed, as updated profile.
  - 3. Include keywords recruiters are looking for from the jobs you are applying for.
  - 4. Try to get recommendations from people to rank higher in recruiters' search results.
  - 5. LinkedIn allows us to target companies and contact people directly at a company you want to work for.

### Portfolio

- A way to showcase your big projects.
- Allows you to demonstrate your value.
- Projects inside portfolio are more important than the portfolio itself.
- Can be simple, as long as it's fast and looks nice.
- Add to ZTM job board once it's done.

### Email

- Applying for a job through a company's website or job board is not the best way to apply.
- Employee referral has proven to be the best way to get an interview.
- The most obvious method is to apply to places where friends and colleagues can refer you.
- Use LinkedIn to find people to send direct messages to.
- Use tools to find people's email addresses.
- Target people who are gatekeepers.
- Most big companies have incentives for referring someone.
- Doesn't have to be online only, meetups and hackathons work too.
- Nothing beats a referral.
- Rather than sending a resume, send a link to your portfolio and directly ask if you can come in for an interview. Ask the head of HR if you wish.
- Message lead developers or CTO and let them know you are interested in working for their company, would like to be where they are professionally. But don't ask for a job directly, rather ask whether they can meet for coffee to talk about themselves, and perhaps you can learn from them and find a referral.
- Message CEO or president directly for smaller companies.
- sample message:

Hey $BOB,
I saw your presentation at $CONFERENCE last year on Youtube (rr point to some work they have done).
Great stuff; loved what you did with $FOO, in particular
$COMMENT_PROVING_YOU_KNOW_WHAT_YOU'RE_TALKING_ABOUT.
I'm also a $FOO developer. I noticed that your company is hiring
or $ROLE. I’d love to be a part of your team. Do you have a
few minutes to chat on Thursday about what you guys are doing?

Thanks,
Yourname
Your website or any public profile link

### Where to finds jobs

- Development is highly in demand, so there are a tonne of resources.
- The better you get at engineering, the easier it will be to find work.
- Resources:
  - LinkedIn
  - [Hackernews who is hiring?](https://www.google.com/search?client=firefox-b-d&q=hackernews+who+is+hiring)
  - [AngelList](https://angel.co/jobs)
  - [Design Modo](https://designmodo.com/jobs/)
  - [Remote List](https://www.remotelist.pw/)
  - [Remote Only](https://remoteonly.io/)
  - [We Work Remotely](https://weworkremotely.com/)
  - [Remote OK](https://remoteok.io/)
  - [Meetup](https://www.meetup.com/): great way to network for referrals.
  - Google e.g. site:linkedin.com \$companyName recruiter
  - [Hired](https://hired.com/), [Triplebyte](https://triplebyte.com/), [Whitetruffle](https://whitetruffle.com/): code quiz sites
- job hunting is a numbers game. for 2% hit rate, apply to 50 companies.
- Blindly applying to companies is much less efficient than targeting directly i.e. eventual referral.

### When to start applying for jobs

- Short answer is -- Apply now! Use it as practice.
- Interviews shouldn't be looked at like win or lose, more they are a skill to be developed.
- The more interviews you take, the better you will become at taking them.
- If you are applying to a job where you check all the boxes is a bad thing for growth.
- Job description is a guideline for what work you will be doing, rather than what you have done in the past.
- Do you know the fundamental building blocks of computer science?
- Have and can you build big projects on your own?
- Hiring developers and engineers are more than just technical knowledge.
- If you never ask the answer is always "no"!

### Summary

- Don't apply to 1000 positions online just sending resume everywhere, like most people.
- Pick 5-10 companies you want to work for, and fully target and focus on applying to them.
- Increase chances of interview by setting up all points covered here over a week.
- Focus on the projects to talk about in interview.
- Contact directly and get referrals rather than applying anonymously.
- The focus is on quality over quantity.

## Big O

A paradigm to classify code according to how runtime or space requirements grow as the input size grows.

- One of the most important topics for software engineering.
- A concept that will always be relevant and make you a better engineer.
- You won't get by any of the big company's interviews without knowing big O.
- Full name is big o asymptotic analysis.
- Big O helps us tell how well a problem is solved.
- Two main things to define good code:
  - 1. Readability: Clean, easy to follow.
  - 2. Scalable: Big O allows us to measure.
- The "runtime" is how much time it takes to run through a function or task.
- Big O measures the performance of code.
- Code runs at different speeds depending on the computer it's running on.
- Big O notation is the language we use to talk about how long an algorithm takes to run: algorithmic efficiency.
- Defines how well code will run regardless of the machine that's running it.
- The less that the function slows down with scale, the better the code is.
- Big O concerns us with how many steps are in a function.
- Scalability defined by the size of the input (n) compared to the number of operations that increase.
- O(n) is linear time, and probably the most common notation, where the number of operations increases proportionally with the number of inputs.
- O(1) is constant time. The number of operations remains constant regardless of the input size.
- Big O rule book:
  - 1. Worst case
    - when calculating big O we always calculate the worst case.
  - 2. Remove constants
    - we only care about input for scalability. Trim out constants.
  - 3. Different terms for inputs.
    - When two more than one input is given to correct notation should be applied.
    - Easy rule of thumb is that any functions that occur in the same indentation would be O(a + b) and any nested functions would be O(a \* b) i.e. O(n^2) quadratic time.
  - 4. Drop non-dominants
    - The most significant term should be what defines big O e.g. O(n + n^2) would become O(n^2)
- To write scalable code means thinking long term, what could happen in the future.
- Everything has a cost to it.
- O(n!) is factorial time, and the most expensive. Nested loop for every input there is!
- for scalable code there are two things we need to consider:
  - 1. Speed: How fast is the runtime - time complexity.
  - 2. Memory: How much RAM does the code require - space complexity.
- Which code is best can be answered with the three pillars of code:
  - **1. Readable**
  - **2. Speed**
  - **3. Memory**
- There is usually a trade-off for any solution between speed and memory.
- When a program executes it has two ways to remember things:
  - 1. Heap: usually where we store variables.
  - 2. Stack: where we keep track of function calls.
- Space complexity is caused by:
  - 1. Variables
  - 2. Data structures
  - 3. Function calls
  - 4. Allocations
- One of the biggest gotchyas is that we don't count the space of inputs.
- We only have control over what happens inside of the function, so input space is ignored.
- We look at whether we are adding space inside the function.

## How to solve coding problems.

How to approach problems and solve them in the optimal way for interviews.

- An interview is a way for the company to find out whether you can solve problems.
- If you can solve problems then you are valuable.
- It's not the smartest interviewer that gets hired, it's the one who can solve the company's problems.
- It's not necessarily about the solution to the problem in interview, it's about the thought process.
- Companies are looking for four things:
  1. Analytical skills
  2. Coding skills
  3. Technical skills
  4. Communication skills
- In order to solve coding problems in interview we need to know the following:
- **Data structures:**
  - Arrays
  - Stacks
  - Queues
  - Linked Lists
  - Trees
  - Tries
  - Graphs
  - Hash Tables
- **Algorithms:**
  - Sorting
  - Dynamic programming
  - BFS & DFS
  - Recursion
- [Google Interview](https://www.youtube.com/watch?v=XKu_SEDAykw)
- Always think out loud and explain your approach, even if you think you know the answer, allowing the interviewer opportunity to steer you if needed to ensure you understand the problem correctly.
- Communicating a naive / brute force solution first, often O(n^2), shows you are thinking clearly about the problem.
- Thinking in small logical steps is much better than trying a more complicated solution straight away.
- Don't try to solve the problem fast.
- Don't try to memorize problems, instead practice fundamentals to tackle any problem.
- The assumption is that some people solve problems better than others, but in reality like anything you can train.

## Data structures

How to organize, format and store collections of data values, the relationships among them, and the functions or operations that can be applied to the data.

- A data structure is a collection of values used to organize data.
- Values can have relationships between them and functions applied to them.
- Each data structure is good and is specialized for its own thing.
- Algorithms are the steps or processes that we put into place to manipulate the values in data structures
- A person who knows how data structures & algorithms can write great programs.
- Data structures & algorithms are timeless, and can be applied to any language or problem.
- There is always a tradeoff between readability, memory and speed (3 pillars).
- Two parts to understanding data structures:
  - 1. How to build
  - 2. How to use - most important!
- In order to understand data structures we need to look at how computers work at the fundamental level.
- Computer needs to be able to keep track for variables which are stored in RAM.
- RAM is much faster than persistent storage for CPU access.
- RAM has numbered address which each hold 8 bits (1 byte).
- CPU connects to memory controller which reads and writes from RAM.
- Bits can be accessed at any random address instantly.
- Programs can run faster when accessing memory addresses that are close to one another.
- CPU cache optimizes further by storing recently accessed data from memory.
- You can define the way you interact with data and how it is arranged in RAM.
- Some data structures are organized next to each other and some are apart, and each have different pros and cons on access and write.
- Our goal is to minimize the operation that the COP needs to do to read and write information.
- That's why data structures are so powerful, because we can think on the the low level about how data structures affect the process of our computers.
- Each data structure performs operations differently.
- Operations on data structures:
  - Insertion: add a new data item in a given collection of items.
  - Deletion: remove data.
  - Traversal: access each data item exactly once so that it can be processed.
  - Searching; find the location of a data item if it exists in a certain collection.
  - Sorting: sorting data.
  - Access: how do we access data.

### Arrays

- Sometimes called lists.
- Organize data sequentially in memory (contiguous).
- Probably the simplest and most widely used data structure.
- Smallest footprint of any data structure.

  - search: O(n)
  - lookup: O(1)
  - append: O(1) or worst case O(n) based on reallocation of memory
  - insert: O(n)
  - delete: O(n)

- Two types of arrays: Static and dynamic
- Static arrays are fixed in size - need to specify the number of elements ahead of time.
- Arrays are allocated in adjacent blocks of memory when created, but there is no way to guarantee that later adding to the array will use more adjacent blocks. Static arrays solve this problem.
- Dynamic arrays allow us to copy and rebuild an array at a new location in memory, with more memory if required.
- JavaScript arrays work like dynamic arrays and automatically allocate memory.
- We can create our own data structures, any we want from scratch.
- **Top tip:** Treat and string questions in interviews like array questions. Strings are simply an array of characters. Convert into array, perform operations, return as string!
- The good:
  - Fast lookups
  - Fast push/pop
  - Ordered
- The bad:
  - Slow search
  - Slow insert
  - Slow delete
  - Fixed size (with static arrays)

### Hash tables

- AKA hash maps, maps, unordered maps, dictionaries, objects depending on language.
- Objects in JavaScript are a type of hash table.
- Seen a lot in databases and caches.
- Made up of key: value pairs.
- A hash function is simply a function that generates a value of fixed length for each input that it receives.
- Hash functions are one way, it's practically impossible to retrieve input.
- A hash function is **idempotent** - always produces the same output when provided with a certain input.
- Hash functions are optimized to be very fast for the purpose of hash tables.
- Some hash functions are very slow e.g. SHA-256 for encryption.
- In hash tables, the key is passed into the hash function, then the outputted hash is mapped to a memory address where the data is stored.
- Usually time complexity of O(1) - constant time

  - search: O(1)
  - lookup: O(1) - or can be O(n) due to hash collisions.
  - insert: O(1)
  - delete: O(1)

- Hash collision occurs when the same address space is allocated for more than one entry based on the hash output.
- This results in the 'bucket' which stores key / value pair having overflow entries.
- Theoretically due to collision read / write can be O(n/k) (O(n) simplified) where k is the size of the hash table.
- Many ways to deal with hash collisions - see [Wiki](https://en.wikipedia.org/wiki/Hash_table).
- in JavaScript ES6 the Map() object allows you to save any data type as the key, instead of only strings pre-ES6.
- Another benefit of Map is is that it maintains insertion order.
- ES6 Set() in JS stores only keys, no values.
- The good:
  - Fast search
  - Fast lookup
  - Fast insert
  - Fast delete
  - Flexible keys
- Thee bad:
  - Unordered
  - Slow key iteration
  - Collisions

### Linked lists

- Two types to be covered: singly and doubly linked lists
- A singly linked list contains a set of node, each containing two elements: a value and a pointer to the next node.
- There is a head and tail node to indicate beginning and end of the list.
- Linked lists are null terminated, i.e. tail node points to null.
- In arrays each item is indexed. In linked lists you start at the head and traverse the list - O(n).
- Memory addresses are not sequential, so unable to take advantage of caching systems for speed advantage.
- Traversing linked lists is usually slower than iterating through array items.
- However inserts into the middle of linked lists is faster than in an array.

  - Prepend: O(1)
  - Append: O(1)
  - Lookup: O(n)
  - Insert: O(n)
  - Delete: O(n)

- A pointer is a reference to another place in memory.
- Because JS is garbage collected (memory is managed automatically) pointers are deleted when data is deleted.
- Doubly linked lists exactly the same as singly linked lists, but have additional pointer to previous node.
- Doubly linked lists allow us to traverse backwards.
- Lookup can technically be O(n / 2).
- The downside is that we may need to hold an additional block of memory.
- Interviewers love to ask questions about linked lists because it requires a lot of information to be held in your head, and you have to think about the steps.
- Don't memorize the implementation, learn to think about the steps.
- Singly vs Doubly:
  - Singly is simpler
  - Singly requires less memory
  - Singly can't be traversed in reverse.
  - Singly for insertion & deletion and not much searching
  - Doubly for searching and deletion of previous nodes
  - Doubly fairy complex, and requires more memory.
- Most of the time in interviews singly linked lists are asked about.
- Reversing a linked list is a very popular question, and probably the hardest concept to grasp in this entire course!
- The good:
  - Fast insert
  - Fast delete
  - Ordered
  - Flexible size
- Thee bad:
  - Unordered
  - Slow lookup
  - More memory

### Stacks & queues.

- Both linear data structures allowing sequential traversal.
- No random access, usually only the first and last elements.
- Having a limited ability on certain data structures can be an advantage.
- By limiting what a user can do it gives control to use only efficient operations.

- Stacks:

  - Lookup: O(n)
  - Pop: O(1)
  - Push: O(1)
  - Peek: O(1)

- Queues:

  - Lookup: O(n)
  - Enqueue: O(1)
  - Dequeue: O(1)
  - Peek: O(1)

- Stacks are LIFO (last in first out).
- Queues are FIFO (first in first out).
- Arrays have cache locality for technically faster access when items are next to each other, whereas linked list memory addresses are scattered. Linked lists however have more dynamic memory, whereas static arrays would need to reallocate memory when capacity is reached. Stacks could be implemented with either depending on the situation.
- Queues should never be implemented with arrays since queue / dequeue would require reindexing.
- One of the most common interview questions is to implement a queue using stacks.
- The good:
  - Fast operations
  - Fast peek
  - Ordered
- Thee bad:
  - Slow lookup
