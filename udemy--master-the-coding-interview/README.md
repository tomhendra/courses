<div align=center>
<img alt="Tom Hendra logo" src="https://res.cloudinary.com/tomhendra/image/upload/v1567091669/tomhendra-logo/tomhendra-logo-round-1024.png" width="100" />
<h1>Master the Coding Interview: Data Structures & Algorithms</h1>
<p>Notes from the course.</p>
</div>

## Introduction

This is a **[Udemy course](https://www.udemy.com/course/master-the-coding-interview-data-structures-algorithms/)**. by Andrei Neagoie.

The JavaScript files are run with [parcel](https://parceljs.org/getting_started.html):

```sh
parcel index.html
```

The introduction explains that the course is made up of two main parts.

- 1. Non-technical aspects of interviews.
- 2. Technical interview topics: data structures & algorithms.

## Getting More Interviews

How to ensure you get more interviews through using the best channels and tactics.

- Being great at anything won't get you a job without getting an interview.
- The more interviews you get, the better your chances are to get a great job.
- Practising interview skills is key to performing well in interviews.
- First step is actually getting the interview.
- If you applying to 100 jobs and only getting one interview, you're probably doing something wrong.
- Should not take any more than a week to set yourself up for applying to jobs.

### Resumes

- Resumes are scanned in 10 seconds by recruiters and are simply a way to get interviews.
- Spend no longer than a day on your resume.
- Have words and characteristics from job posts you want to apply for on the resume.
- Make the resume personal to each job you apply to so you have the company name on resume.
- Use online tools to generate well designed resume. Your time is better spent writing code!
- Companies often use algorithms to search for keywords from the job listing.
- key points for resume:
  - should be one page only.
  - Should only contain relevant skills, using keywords from job description.
  - Should be personalized for each application. One of the biggest mistakes is not doing so.
  - should be an online link to portfolio or GitHub etc.
- Resume cheat sheet:
  - ✅ Use a pre-designed resume template
  - ✅ Make the resume fit on 1 page
  - ✅ Include words from job description
  - ✅ Include company name you are applying to
  - ✅ Does your first item on your resume reflect what they are looking for?
  - ✅ Experience titles demonstrate value
  - ✅ Do you have an online link?
  - ✅ Remove the word “I”
  - ✅ No buzzwords describing how great you are
  - ✅ Are you using Action words?
  - ✅ Measure everything in terms of impact, don’t just describe your responsibilities
  - ✅ Technical Knowledge/Skills should include what they are looking for. Only show years if it is impressive
  - ✅ Include only sections/items that are impressive: Experience, Projects, Education, Technical Skills
  - ✅ No typos or bad grammar

### What if I lack experience?

- Apply to jobs that you are under-qualified for.
- Job postings are designed to weed out the weak candidates.
- If you are applying to a job that you are 100% qualified for, how will you grow?
- You can demonstrate experience without having a past job by having 3 of the below:
  - GitHub: Make commits. Contribute to open source.
  - Website: Doesn't need to be complicated.
  - 1-2 big projects: Big, challenging projects much better than numerous simple ones.
  - Blog

### LinkedIn

- If you craft things well enough, you will get lots of recruiters' contact.
- Should be similar to your resume.
- Recruiters usually search LinkedIn for keywords.
  - 1. Apply for jobs through LinkedIn.
  - 2. Update your profile every week on LinkedIn to show up in recruiter's feed, as updated profile.
  - 3. Include keywords recruiters are looking for from the jobs you are applying for.
  - 4. Try to get recommendations from people to rank higher in recruiters' search results.
  - 5. LinkedIn allows us to target companies and contact people directly at a company you want to work for.

### Portfolio

- A way to showcase your big projects.
- Allows you to demonstrate your value.
- Projects inside portfolio are more important than the portfolio itself.
- Can be simple, as long as it's fast and looks nice.
- Add to ZTM job board once it's done.

### Email

- Applying for a job through a company's website or job board is not the best way to apply.
- Employee referral has proven to be the best way to get an interview.
- The most obvious method is to apply to places where friends and colleagues can refer you.
- Use LinkedIn to find people to send direct messages to.
- Use tools to find people's email addresses.
- Target people who are gatekeepers.
- Most big companies have incentives for referring someone.
- Doesn't have to be online only, meetups and hackathons work too.
- Nothing beats a referral.
- Rather than sending a resume, send a link to your portfolio and directly ask if you can come in for an interview. Ask the head of HR if you wish.
- Message lead developers or CTO and let them know you are interested in working for their company, would like to be where they are professionally. But don't ask for a job directly, rather ask whether they can meet for coffee to talk about themselves, and perhaps you can learn from them and find a referral.
- Message CEO or president directly for smaller companies.
- sample message:

Hey $BOB,
I saw your presentation at $CONFERENCE last year on Youtube (rr point to some work they have done).
Great stuff; loved what you did with $FOO, in particular
$COMMENT_PROVING_YOU_KNOW_WHAT_YOU'RE_TALKING_ABOUT.
I'm also a $FOO developer. I noticed that your company is hiring
or $ROLE. I’d love to be a part of your team. Do you have a
few minutes to chat on Thursday about what you guys are doing?

Thanks,
Yourname
Your website or any public profile link

### Where to finds jobs

- Development is highly in demand, so there are a tonne of resources.
- The better you get at engineering, the easier it will be to find work.
- Resources:
  - LinkedIn
  - [Hackernews who is hiring?](https://www.google.com/search?client=firefox-b-d&q=hackernews+who+is+hiring)
  - [AngelList](https://angel.co/jobs)
  - [Design Modo](https://designmodo.com/jobs/)
  - [Remote List](https://www.remotelist.pw/)
  - [Remote Only](https://remoteonly.io/)
  - [We Work Remotely](https://weworkremotely.com/)
  - [Remote OK](https://remoteok.io/)
  - [Meetup](https://www.meetup.com/): great way to network for referrals.
  - Google e.g. site:linkedin.com \$companyName recruiter
  - [Hired](https://hired.com/), [Triplebyte](https://triplebyte.com/), [Whitetruffle](https://whitetruffle.com/): code quiz sites
- job hunting is a numbers game. for 2% hit rate, apply to 50 companies.
- Blindly applying to companies is much less efficient than targeting directly i.e. eventual referral.

### When to start applying for jobs

- Short answer is -- Apply now! Use it as practice.
- Interviews shouldn't be looked at like win or lose, more they are a skill to be developed.
- The more interviews you take, the better you will become at taking them.
- If you are applying to a job where you check all the boxes is a bad thing for growth.
- Job description is a guideline for what work you will be doing, rather than what you have done in the past.
- Do you know the fundamental building blocks of computer science?
- Have and can you build big projects on your own?
- Hiring developers and engineers are more than just technical knowledge.
- If you never ask the answer is always "no"!

### Summary

- Don't apply to 1000 positions online just sending resume everywhere, like most people.
- Pick 5-10 companies you want to work for, and fully target and focus on applying to them.
- Increase chances of interview by setting up all points covered here over a week.
- Focus on the projects to talk about in interview.
- Contact directly and get referrals rather than applying anonymously.
- The focus is on quality over quantity.

## Big O

A paradigm to classify code according to how runtime or space requirements grow as the input size grows.

- One of the most important topics for software engineering.
- A concept that will always be relevant and make you a better engineer.
- You won't get by any of the big company's interviews without knowing big O.
- Full name is big o asymptotic analysis.
- Big O helps us tell how well a problem is solved.
- Two main things to define good code:
  - 1. Readability: Clean, easy to follow.
  - 2. Scalable: Big O allows us to measure.
- The "runtime" is how much time it takes to run through a function or task.
- Big O measures the performance of code.
- Code runs at different speeds depending on the computer it's running on.
- Big O notation is the language we use to talk about how long an algorithm takes to run: algorithmic efficiency.
- Defines how well code will run regardless of the machine that's running it.
- The less that the function slows down with scale, the better the code is.
- Big O concerns us with how many steps are in a function.
- Scalability defined by the size of the input (n) compared to the number of operations that increase.
- O(n) is linear time, and probably the most common notation, where the number of operations increases proportionally with the number of inputs.
- O(1) is constant time. The number of operations remains constant regardless of the input size.
- Big O rule book:
  - 1. Worst case
    - when calculating big O we always calculate the worst case.
  - 2. Remove constants
    - we only care about input for scalability. Trim out constants.
  - 3. Different terms for inputs.
    - When two more than one input is given to correct notation should be applied.
    - Easy rule of thumb is that any functions that occur in the same indentation would be O(a + b) and any nested functions would be O(a \* b) i.e. O(n^2) quadratic time.
  - 4. Drop non-dominants
    - The most significant term should be what defines big O e.g. O(n + n^2) would become O(n^2)
- To write scalable code means thinking long term, what could happen in the future.
- Everything has a cost to it.
- O(n!) is factorial time, and the most expensive. Nested loop for every input there is!
- for scalable code there are two things we need to consider:
  - 1. Speed: How fast is the runtime - time complexity.
  - 2. Memory: How much RAM does the code require - space complexity.
- Which code is best can be answered with the three pillars of code:
  - **1. Readable**
  - **2. Speed**
  - **3. Memory**
- There is usually a trade-off for any solution between speed and memory.
- When a program executes it has two ways to remember things:
  - 1. Heap: usually where we store variables.
  - 2. Stack: where we keep track of function calls.
- Space complexity is caused by:
  - 1. Variables
  - 2. Data structures
  - 3. Function calls
  - 4. Allocations
- One of the biggest gotchyas is that we don't count the space of inputs.
- We only have control over what happens inside of the function, so input space is ignored.
- We look at whether we are adding space inside the function.

## How to solve coding problems.

How to approach problems and solve them in the optimal way for interviews.

- An interview is a way for the company to find out whether you can solve problems.
- If you can solve problems then you are valuable.
- It's not the smartest interviewer that gets hired, it's the one who can solve the company's problems.
- It's not necessarily about the solution to the problem in interview, it's about the thought process.
- Companies are looking for four things:
  1. Analytical skills
  2. Coding skills
  3. Technical skills
  4. Communication skills
- In order to solve coding problems in interview we need to know the following:
- **Data structures:**
  - Arrays
  - Stacks
  - Queues
  - Linked Lists
  - Trees
  - Tries
  - Graphs
  - Hash Tables
- **Algorithms:**
  - Sorting
  - Dynamic programming
  - BFS & DFS
  - Recursion
- [Google Interview](https://www.youtube.com/watch?v=XKu_SEDAykw)
- Always think out loud and explain your approach, even if you think you know the answer, allowing the interviewer opportunity to steer you if needed to ensure you understand the problem correctly.
- Communicating a naive / brute force solution first, often O(n^2), shows you are thinking clearly about the problem.
- Thinking in small logical steps is much better than trying a more complicated solution straight away.
- Don't try to solve the problem fast.
- Don't try to memorize problems, instead practice fundamentals to tackle any problem.
- The assumption is that some people solve problems better than others, but in reality like anything you can train.

## Data structures

----- \$summary -----

- A data structure is a collection of values used to organize data.
- Values can have relationships between them and functions applied to them.
- Each data structure is good and is specialized for its own thing.
- Algorithms are the steps or processes that we put into place to manipulate the values in data structures
- A person who knows how data structures & algorithms can write great programs.
- Data structures & algorithms are timeless, and can be applied to any language or problem.
- There is always a tradeoff between readability, memory and speed (3 pillars).
- Two parts to understanding data structures:
  - 1. How to build
  - 2. How to use - most important!
- In order to understand data structures we need to look at how computers work at the fundamental level.
- Computer needs to be able to keep track for variables which are stored in RAM.
- RAM is much faster than persistent storage for CPU access.
- RAM has numbered address which each hold 8 bits (1 byte).
- CPU connects to memory controller which reads and writes from RAM.
- Bits can be accessed at any random address instantly.
- Programs can run faster when accessing memory addresses that are close to one another.
- CPU cache optimizes further by storing recently accessed data from memory.
- You can define the way you interact with data and how it is arranged in RAM.
- Some data structures are organized next to each other and some are apart, and each have different pros and cons on access and write.
- Our goal is to minimize the operation that the COP needs to do to read and write information.
- That's why data structures are so powerful, because we can think on the the low level about how data structures affect the process of our computers.
- Each data structure performs operations differently.
- Operations on data structures:
  - Insertion: add a new data item in a given collection of items.
  - Deletion: remove data.
  - Traversal: access each data item exactly once so that it can be processed.
  - Searching; find the location of a data item if it exists in a certain collection.
  - Sorting: sorting data.
  - Access: how do we access data.
